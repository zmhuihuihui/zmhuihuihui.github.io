<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开源文化</title>
      <link href="/2019/10/26/kai-yuan-wen-hua/"/>
      <url>/2019/10/26/kai-yuan-wen-hua/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;最近又在阅读《大教堂与集市》这一本书，从书名就可以看出，描述的是“大教堂”与“集市”两种经典的软件开发模式。“大教堂”描述的是传统的大规模软件开发模式，“集市”描述的是开源的软件开发模式。整本书的核心便是大教堂与集市这一章，详细的阐述了集市模式背后的成功的原因，对比与传统大规模开发模式的不同并分析其开发模式的优缺点。</p><p>&emsp;&emsp;书的开头阐述了黑客以及黑客文化。“黑客”的含义并非如今利用系统漏洞进行攻击的网络黑客，而是泛指那些狂热的程序员。这些黑客一起狂热的共事，解决大量的复杂的技术难题，形成了优秀的黑客文化，对人类生活工作以及经济的发展有着巨大的作用。早期黑客致力于研究c语言、UNIX等，这些都是早期集市模式的成功案例。</p><p>&emsp;&emsp;集市模式被广泛的传播与实践，是在Linux取得巨大成功后。Linux最重要的特点并非是在技术上，而是在社会学上。在此之前，所有人都认为像操作系统这种复杂的软件，必定需要一个精细制作，配合紧密的精致团队，也就是“大教堂”模式来开发，在早期这是常见的大型软件的开发模式。但Linus并没有采取传统的开发模式，而是走了一条不同寻常的道路——“集市”模式。Linus作为主团队成员，在网上对Linux项目开源，由互联网上大量的黑客来共同修改，出乎意料的是，这种开发模式取得了颠覆性的成功。</p><p>&emsp;&emsp;那么Linux看似是网络上毫无配合的黑客的随意之作，为什么产生了如此大的成功？作者在文中通过自身实践得出了以下结论。在传统的开发者模式中，很多程序员仅仅把它当成一份工作，一项任务，并没有本身热爱这个产品。而开源软件集聚了许多共通热爱的黑客，其大会的作用是巨大的。其次，传统开发模式中，用户仅仅使用体验产品，并没有专业的知识能力来评定这一软件的优劣，也同样没有机会与软件的开发人员进行交流与反馈。而开源软件的开发模式不同，参与修改的黑客本身作为一种用户，在使用体验软件的同时可以精准的看到系统的漏洞，提出修改，这可以有效的提升代码的质量以及快速定位错误排除错误。同时，传统的开发模式中，一个软件项目得功能完善后才上线，而开源软件提倡的是“早发布，常发布”的开发模式，把不完善的功能开源，倾听用户的建议，做到经常更新迭代原来的项目，不断完善功能优化。这些就是集市模式较于大教堂模式优秀的地方。</p><p>&emsp;&emsp;文中作者还大量阐述了Linus定律。Linus定律描述的是如果有足够多的beta测试者和合作开发者，几乎所有问题会很快的显现，并有人会来解决。Linus定律其实表达了大教堂模式与集市模式之间关键的区别，对于大教堂模式的开发者来说，往往发现BUG是棘手的，这些BUG隐藏在深处难以发现，需要花费大量的人力成本与时间成本来发现，而对于集市模式来说，集市模式用于上千名热诚的合作开发者来钻研，可以使得BUG变得显而易见，然后频繁的发布新版本来更正已有的错误，大大的提高了开发的效率。总之，对于大教堂开发模式来说，其软件是不开源的，所以开发者和用户往往受限于自己的角色，对相同的程序有不匹配的思维方式，起不到交流反馈的作用，而对于集市开发模式来说，其软件是开源的，开发者和用户都能看到真实的代码，他们之间的交流往往是有效的。</p><p>&emsp;&emsp;在《人月神话》这本书中，我们知道软件开发受限于Brooks定律，即在一个延期的项目上增加人手，只会是项目更加延期。因为人月不可交换，人与人之间的交流沟通会使拖延项目的进度。那么在开源项目中，似乎不受Brooks定律的约束，因为大量的合作开发者通过互联网对项目进行修改，而这些开发者之间很进行有效的沟通交流。作者在文中给出了他的结束，Brooks定律成立是有前提条件的，需要其开发人员之间的沟通是一个完全图。而在集市模式中，大部分合作开发者往往分布在不同的并行的子任务中，其任务之间互不干扰，他们实际上不需要互相沟通，只需将修改的代码和BUG的报告提交给核心团队处理，因此只有核心团队会受到Brooks定律的约束，而往往核心团队的人数只占整个开发团队的小小一部分。</p><p>&emsp;&emsp;整本书主要围绕黑客精神和开源文化而展开，作者通过自己emil项目的例子，解释了集市模式的运作与背后成功的原理。这本书对软件行业与互联网行业有巨大的启示作用，影响了整个软件开发领域，被誉为开源运功的《圣经》。正如作者所说的：“由程序员和无政府主义者组成的快乐的网络部落，战胜和压倒了等级森严的传统闭源软件世界”。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《大教堂与集市》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解设计模式—单例模式</title>
      <link href="/2019/10/26/xiang-jie-she-ji-mo-shi-dan-li-mo-shi/"/>
      <url>/2019/10/26/xiang-jie-she-ji-mo-shi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h2><p>单例模式是23种设计模式中较为简单的一种。其模式保证实体类只能创建并返回唯一的一个对象，其结构需要保证 <strong>构造器私有化</strong> 和 <strong>静态方法返回对象</strong>，通过该类的唯一访问方式获得其唯一的对象，可以直接访问此方法，不需要实例化该类的对象。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><p><strong>方法一：饿汉模式</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//构造器私有化</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//该类的唯一对象</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回此对象</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种创建单例模式的方式体现在一个“饿”字，意思就是提前生成好该类的唯一对象，当用户想要此对象时，通过静态方法直接返回该对象。<br>优点：线程安全<br>缺点：如果用户用不到此类，则该创建对象的内存空间就被浪费了</p></li><li><p><strong>方法二：懒汉模式</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//构造器私有化</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//该类的唯一对象</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回此对象</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>和饿汉模式类似，但其不同点在于突出“懒”字，不事先创建好该类的对象，而是当用户需要时再创建此对象。<br>优点：节省内存空间<br>缺点：线程不安全（可以通过synchronized进行加锁来解决，但会阻塞其他线程影响效率）</p></li><li><p><strong>方法三：双重锁模式</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//构造器私有化</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//该类的唯一对象</span>  <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回此对象</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>为了保证线程安全可以使用双重锁机制，如果多个线程进入if中，通过synchronized加锁机制保证只有一个线程来创建对象，其他线程通过volatile关键字进行同步避免JVM重排优化，从主存中拿到刚刚创建好的对象再返回。<br>优点：线程安全，节省内存空间</p></li><li><p><strong>方法四：静态内部类</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//构造器私有化</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//静态内部类创建对象</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInner</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//返回此对象</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> SingletonInner<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>静态内部类只会在getInstance()方法被调用时才会初始化，解决了内存浪费的情况，同好保证了多线程的安全访问。<br>优点：线程安全，节省内存空间</p></li><li><p><strong>方法五：枚举类</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//唯一对象</span>  INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>枚举类自身优势可以保线程安全，同时隐藏了私有构造器，其中只要定义一个对象就能实现单例模式。实现较为简单。在单例模式的所有实现中，推荐使用此方法来实现。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解String中的intern()方法</title>
      <link href="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/"/>
      <url>/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="String基础知识"><a href="#String基础知识" class="headerlink" title="String基础知识"></a>String基础知识</h3><p>在Java中创建String对象有两种方法分别为：</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>String b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这两种方法有什么本质的区别呢？先来看看 <strong>String a = “123”</strong> ;是如何生成的，其主要步骤分为两步：<br>1、判断常量池有没有“123”对象<br>2、如果有，a直接指向“123”；如果没有，在常量池创建“123”对象，然后使a指向。<br><img src="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/1.png" alt="直接赋值过程"><br>由于之前常量池没有“123”对象，所以就创建一个并使a指向它。 </p><p>接着，来看看String b = new String(“456”);是如何创建的，其主要步骤也分为两步：<br>1、在堆内存中单独开辟出一个内存空间存放“456”对象，使b指向它。<br>2、如果常量池中没有“456”对象则创建，如果有则不创建。<br><img src="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/2.png" alt="new创建过程"></p><p>在了解两种不同的创建String类的方法，就可以得到以下两个结论：</p><ul><li>使用直接赋值，如果对象内容是一样的，则引用地址也是一样的。</li><li>使用new赋值，即使对象内容是一样的，引用地址也是不一样的。</li></ul><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>String b <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span>String c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span></code></pre><h3 id="解析intern-方法"><a href="#解析intern-方法" class="headerlink" title="解析intern()方法"></a>解析intern()方法</h3><p>在String中有一个intern()方法，用到的地方不是很多。其方法的作用涉及到底层JVM。并且在不同版本JDK中，得到的结果也不一样。</p><p>在 <strong>JDK1.6及以前</strong> ，intern()方法是这样描述的：</p><blockquote><p>当字符串在常量池存在时，则返回常量池中的字符串；当字符串在常量池不存在时，则在常量池中 <strong><em>拷贝</em></strong> 一份，然后再返回常量池中的字符串。</p></blockquote><p>还是拿之前的两种不同创建方式为例，分别调用其intern()方法由于两种创建对象的方法都会在常量池中有一份字符串，所以直接返回常量池对象。区别在于，返回的引用地址不同，其过程如下：<br><img src="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/3.png" alt="两种方式分别调用intern()"></p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>String m <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span>String b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String n <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span></code></pre><p>之前的例子是已经在常量池中存在字符串了，相对容易理解一些。还存在一种可能就是常量池如果没有字符串，看以下的例子：</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span></code></pre><p>这个过程又如何理解呢？一步一步来分析，首先第一行String a = new String(“1”)+new String(“2”);应分分为三步来完成：<br>1、分别在堆内存和常量池创建“1”字符串<br>2、分别在堆内存和常量池创建“2”字符串<br>3、运算加法，在堆内存中创建“12”字符串（注意：加法由StringBuffer实现，并不会在常量池中也创建）<br><img src="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/4.png" alt="第一行运算结果示意图"><br>此时，走到第二步a.intern();根据上面在JDK1.6的定义，是在常量池中拷贝一份“12”字符串，然后将字符串返回给b。<br><img src="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/5.png" alt="第二行运算结果示意图"><br>可以清楚的看到a和b的引用地址并不一样，所以上面代码返回false。</p><p>此时再来看看 <strong>JDK1.6以后</strong> 是如何定义intern()方法的：</p><blockquote><p>当字符串在常量池存在时，则返回常量池中的字符串；当字符串在常量池不存在时，则把 <strong><em>堆内存中此对象引用添加到常量池中</em></strong> ，然后再返回此引用。</p></blockquote><p>前半句话，和JDK1.6及以前一摸一样，关键的变化在于后半句话。因此，如果字符串已经在常量池中的话，是和JDK1.6及以前没有任何区别的。所以仍然满足：</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>String m <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span>String b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String n <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span></code></pre><p>但当常量池中没有字符串时情况就发生了变化,还是以上述的例子为例：</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span></code></pre><p>此时看到，答案与之前不同了，那么整个过程与之前发生了怎样的变化，同样一步一步来分析，第一步是一样的：<br> <img src="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/6.png" alt="第一行运算结果示意图"><br> 当执行到第二步 String b = a.intern();时就发生了变化：<br> <img src="/2019/10/21/xiang-jie-string-zhong-de-intern-fang-fa/7.png" alt="第二行运算结果示意图"><br> 可以看到，区别就在于在JDK1.6及以前是将 <strong>堆内存的对象拷贝一份到常量池中</strong>，而在JDK1.6以后是将 <strong>此对象的引用放入常量池中</strong>。所以JDK1.6以后，实际上b指向的是堆内存中的“12”，即和a指向是相同的，所以上述代码返回的是true。</p><p> 综上，在JDK1.6以后通过优化了intern()方法，可以有效的减少内存的占用，提高运行时的性能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中HashMap的实现原理</title>
      <link href="/2019/10/21/java-zhong-hashmap-de-shi-xian-yuan-li/"/>
      <url>/2019/10/21/java-zhong-hashmap-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="Java中HashMap概述"><a href="#Java中HashMap概述" class="headerlink" title="Java中HashMap概述"></a>Java中HashMap概述</h3><p>HashMap作为Map的一种实现方式，会频繁的的Java中使用。HashMap是基于哈希表实现的一种数据结构,每一个元素以一个&lt;key,value&gt;键值对的形式存储,容量不足时,数组长度会自动增长.HashMap是非线程安全的,只适用于单线程环境,多线程环境可以采用并发包下的concurrentHashMap。<br>那么你知道HashMap具体的工作原理，以及为什么是这样工作的吗，本篇文章将带你了解HashMap的底层原理。</p><h3 id="HashMap的基本结构"><a href="#HashMap的基本结构" class="headerlink" title="HashMap的基本结构"></a>HashMap的基本结构</h3><p>HashMap的基本结构要分JDK版本来定：<br>在 <strong>JDK8之前</strong> ,HashMap的结构为 <strong>数组+链表</strong> ，其具体结构如下图：<br><img src="/2019/10/21/java-zhong-hashmap-de-shi-xian-yuan-li/1.png" alt="HashMap结构（JDK8之前）"></p><ul><li>横方向上表示的是数组，方便实现快速的定位查询。</li><li>竖方向上表示的是链表，方便产生冲突时快速的实现插入或删除。</li></ul><p>但这样的结构会有一个缺点，当数组上某一点频繁的产生冲突时，就会形成很长的链表。当我们想要查询时，必须从表头遍历到表尾，这样会极大的消耗时间。因此在JDK8及以后对HashMap的结构进行了优化。</p><p>在 <strong>JDK8及以后</strong> ,HashMap的结构为 <strong>数组+链表+红黑树</strong> ，其具体结构如下图：<br><img src="/2019/10/21/java-zhong-hashmap-de-shi-xian-yuan-li/2.png" alt="HashMap结构（JDK8及以后）"><br>在之前结构的基础上，当数组上某处的链表结点数超过8个时就会把自动的把链表结构转化为红黑树结构。使用红黑树结构的优势在于避免了普通AVL树会出现的左、右子子树会特别高的情况（查询效率等同与链表），同时也权衡了查询以及插入删除的效率。</p><h3 id="HashMap具体实现"><a href="#HashMap具体实现" class="headerlink" title="HashMap具体实现"></a>HashMap具体实现</h3><p>了解了HashMap的结构，来看看HashMap的初始化，当我们new一个HashMap对象时，系统默认会如何构造呢？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span>；  <span class="token comment" spellcheck="true">//数组大小  </span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//加载因子</span></code></pre><p>首先，HashMap会默认给定几个参数，其中最重要是这两个:</p><ul><li>DEFAULT_INITIAL_CAPACITY代表默认的数组大小，1左移4位也就是16。</li><li>DEFAULT_LOAD_FACTOR表示默认的加载因子，值为0.75。</li></ul><p>这里就抛出并解决可以两个问题：</p><p>问题一：为什么数组大小设置为16？（为什么数组大小为2的倍数？）<br>1、2的倍数使JVM只需进行左移操作可以优化性能。<br>2、在OS中分段分页的内存分配都是以2的倍数分配的，可以降低内存碎片的产生。<br>3、可以提高散列度，减少冲突。在后面会讲到，数据存放的位置是通过一个计算公式(n-1)&amp;hash生成的，n代表数组长度，hash表示哈希值，如果n为2的倍数例如16，则它的二进制数为0001_0000，n-1则为0000_1111，与hash值按位与后可以保留后四位，减少了冲突的发生。</p><p>问题二：为什么加载因子设置为0.75？<br>首先要明白什么是加载因子。加载因子代表这Hash数组的填充程度，当数组中的元素个数超过数组大小乘加载因子时（16*0.75=12），则认为该数组饱和了，需要扩充。也就意味着需要在时间与空间上进行取舍。过大的填充因子会导致冲突加大，链表（或红黑树）的查询时间增加，过小的填充因子减少了冲突但会导致数组空间上的浪费。所以0.75是官方给出的相对折中的一个数值。</p><p>接着就是关键部分，初始化完成后，我们想要使用put()方法把&lt;K,V&gt;存储到HashMap中，那么这一过程是如何完成的呢？首先需要知道数据存放的位置，因此必须获取每一个Key的Hash值，其源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到Hash值是如何产生的，key因为继承自Object类本身会有一个hash值，首先调用本身的hash值再与这个hash值右移16位相异或。那么问题来了，为什么不直接返回key本身的hash值呢？这个问题一会再讨论。</p><p>有了新的hash值，就会把hash值，key，value等参数丢掉一个putVal()的函数中。由于源码分析起来太过于枯燥复杂，这里就大致讲一下流程。<br>首先想想数组中的元素应该有哪些什么类型？至少会有key和value吧，也应该有hash值，还有作为链表它应该有指向下一个结点的next指针，因此我们先得把这些数据封装在一个对象中，即为Node对象，也就是数组中真正存放的对象。其结构大致如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token keyword">final</span> K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>        ……<span class="token punctuation">}</span></code></pre><p>封装完了数据，我们就得把它插入到HashMap中去，如何找到自己应该存放的位置，HashMap中给出了这样的计算公式 <strong>(n-1)&amp;hash</strong> 。通过公式可以计算出数组下标，如果数组空着的，那正好直接放进去就好了。如果数组被占了且为链表，则找到链尾添加到链尾。如果数组被占了且为红黑树，则调用红黑树的插入方法插入。</p><p>在这个过程中还伴随这两个if判断。第一个判断，如果链表太长了（长度超过默认的8）则自动把链表转换为红黑树。第二个判断，如果插入后数组元素太多了（超过阈值16*0.75=12），则自动扩充数组，直接再左移一位（扩大一倍）。整个流程还是十分清晰的，如果感兴趣，可以带着这个流程去看看源码。</p><p>最后，我们回到之前的问题，为什么不用key本身的hash值呢？<br>可以看出hash值对于整个存储过程来说是十分重要的，影响着冲突的发生，空间与时间的利用率等诸多问题。所以新的hash值肯定会带来一个好处：提高散列度，降低冲突的发生。</p><p>举个例子，现在有两个key本身的hash值，old_key_1和old_key_2，和优化后的新的hash值new_key_1和new_key_2。<br><img src="/2019/10/21/java-zhong-hashmap-de-shi-xian-yuan-li/3.png" alt="例子"><br>我们分别用原hash值和新hash值来通过公式(n-1)&amp;hash计算一下,计算过程如下：<br><img src="/2019/10/21/java-zhong-hashmap-de-shi-xian-yuan-li/4.png" alt="计算过程"><br>通过对比可以发现，如果直接使用key的hash值计算得到的结果是一样的，这样就会产生冲突。而通过优化后的hash值计算得到的结果是不一样的。因此新的hash值可以提高数组的散列度，降低了冲突的可能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解设计模式—观察者模式</title>
      <link href="/2019/10/19/xiang-jie-she-ji-mo-shi-guan-cha-zhe-mo-shi/"/>
      <url>/2019/10/19/xiang-jie-she-ji-mo-shi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="情景引入"><a href="#情景引入" class="headerlink" title="情景引入"></a>情景引入</h3><p>在以前（传统模式），学生上学、大人上班之前都会观察天气预报，以确定出门是否要带雨伞。在这种情况下，因为天气随时都可能发生改变，所以学生或大人需要每隔一段时间去查看天气。这显然会消耗大量的精力，是十分不合理的。</p><p>现在（观察者模式），天气局拥有每个人的信息，只要天气出现变化，就可以自动的通知所有人天气情况，让所有人作出对应的应对策略。这样，不需要学生和大人实时的看天气预报，大大的提高的消息的时效性。</p><p>在上面两个场景中，解释了观察者模式大致的运行流程，结合场景理解得到下图：<br><img src="/2019/10/19/xiang-jie-she-ji-mo-shi-guan-cha-zhe-mo-shi/1.png" alt="观察者模式概念图"></p><p>观察者模式是一对多的关系，其中可以把对象分为两个部分：Subject对象和Observer对象。</p><ul><li><p>Subject对象,即目标对象，相当于场景中的天气局，在观察者模式中有且仅有一个目标对象。其负责管理所有的Observer对象，当Subject中的某个状态改变时，就会触发方法对所有Observer对象进行通知。</p></li><li><p>Observer对象,即观察者对象，相当于场景中的学生、大人……，都统一交由Subject对象管理，在观察者模式中可以包含多个观察者对象。当收到subject发来的通知时，Observer对象就会调用各自的方法来应对。</p></li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>了解了观察者模式中的两大对象：Subject和Observer。就可以深入理解下这两个对象所包含的方法属性即实现原理。</p><p>对于Subject对象，首先需要一个存储Observer对象的列表，负责存储所有的Observer对象。回想场景，应该有新的人想要得到天气通知，也应该有人不想要得到天气通知。所以Subject应该有添加和删除方法来维护Observer列表。最后，还有最重要的是通知方法。</p><p>对于Observer对象，只需要一个得到通知后的应对方法就行。那么，我们就可以得到如下结构：<br><img src="/2019/10/19/xiang-jie-she-ji-mo-shi-guan-cha-zhe-mo-shi/2.png" alt="观察者模式简单结构"><br>其流程是这样的，Subject对象可以随意的添加或删除Object对象。当Subject中状态发生改变时，会自动调用Notify()方法。该方法会对Observer列表中所有Observer对象调用其各自的Update()方法来应对。Subject对象的实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Observer列表</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observerList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//添加Observer对象</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        observerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除Observer对象</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">detach</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        observerList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//通知</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer o <span class="token operator">:</span> observerList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Observer对象的实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述实现只是在分析了场景后逻辑上的实现。但仔细观察会发现很多问题。首先List中存放的应该是统一的对象，所以对于不用类型的Observer应该抽象出一个接口，不同的Observer只需实现其不同update()方法。类似的，对于Subject来说，也同样可以抽象出一个接口，供交通局等其他地方使用。抽象出Subject和Observer接口hou，将耦合变为了抽象耦合，大大减少了原来的耦合程度。</p><p>于是，就有了完整的构造者模式的UML图：<br><img src="/2019/10/19/xiang-jie-she-ji-mo-shi-guan-cha-zhe-mo-shi/3.png" alt="观察者模式类图"></p><h3 id="Java官方实现"><a href="#Java官方实现" class="headerlink" title="Java官方实现"></a>Java官方实现</h3><p>在Java中在util包中，官方提供给了内置的观察者模式，分别为Observable类和Observer接口。</p><p>Observer类相当于Subject接口，相对于之前的Subject接口多了一个setChanged()方法，意为表明目标状态发生了改变，此方法必须在notifyObservers()之前调用。通过继承Observable来实现一下天气局的类，其源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Observable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Vector<span class="token operator">&lt;</span>Observer<span class="token operator">></span> obs<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Observable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//添加Observer</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obs<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            obs<span class="token punctuation">.</span><span class="token function">addElement</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除Observer</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">deleteObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        obs<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//通知Observer</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span>Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> arrLocal<span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>changed<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            arrLocal <span class="token operator">=</span> obs<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">clearChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arrLocal<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>Observer<span class="token punctuation">)</span>arrLocal<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//状态发生改变</span>    <span class="token keyword">protected</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后需要实现一个简单的天气局类，当前默认的天气状态为晴天，通过setState()方法改变天气状态会自动通知所有Observer，其具体实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">weatherDate</span> <span class="token keyword">extends</span> <span class="token class-name">Observable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String state <span class="token operator">=</span> <span class="token string">"晴天"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token function">weatherChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">weatherChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyObservers</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再来看看看官方提供的Observer接口，其源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中只有一个update()方法，但其中有两个参数，一个是Subject对象（天气局对象），一个是Subject对象传来的数据。那么这两个参数是什么意思呢？</p><p>这里就要涉及到两个模型：<strong>推模型</strong> 和 <strong>拉模型</strong>。</p><p>所谓的推模型就是当天气局状态改变时，通知所有Observer时会将一个参数传给Observer供其使用。例如天气从晴天转变为下雨时，可以通过推模型将降雨量这个参数绑定在notifyObservers()方法参数中，传给每个Observer，Observer通过update()接收到这个arg参数时会通过每个人不同的判断决定是否带伞。</p><p>而拉模型正好相反，当天气局状态改变时，通知所有Observer时会将自己这个天气局对象作为参数传给Observer，Observer获得了Subject对象就可以自由的通过其get()方法来获取里面的所有信息。</p><p>所以官方提供在update()方法中提供两个参数，同时支持推模型和拉模型，用户可以根据需求自主选择。接着，可以看一下Observer接口的具体实现，其中以学生类为例,这里使用了其中的推模型，获取Subject对象中的天气状态。具体实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">student</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name <span class="token operator">=</span> <span class="token string">"张三"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天"</span> <span class="token operator">+</span> arg <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"应该..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后在主函数中进行测试：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        weatherDate weather <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">weatherDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student zhangsan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weather<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>zhangsan<span class="token punctuation">)</span><span class="token punctuation">;</span>        weather<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"下雨"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><img src="/2019/10/19/xiang-jie-she-ji-mo-shi-guan-cha-zhe-mo-shi/4.png" alt="运行结果"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>观察者模式定义的是一对多的依赖关系，一个被观察者可以拥有多个观察者，并且通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。其在Java中被广泛应用，其中较为经典的就是事件监听机制，其本质就是观察者模式。组件作为目标对象，不同的触发事件作为观察者对象，当组件被触发时，自动在观察者中判断属于哪个事件，然后事件作出相应策略。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以人为本</title>
      <link href="/2019/10/19/yi-ren-wei-ben/"/>
      <url>/2019/10/19/yi-ren-wei-ben/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“工作中的很多问题属于社会学范畴，而非技术范畴。”  —《人件》</p></blockquote><p>&emsp;&emsp;趁着国庆的空闲时间，阅读完了《人件》，此书和《人月神话》并称为软件工程管理领域最为璀璨的双子星。如果说《人月神话》的核心讲的是软件项目管理及相关技术，那么《人件》的核心讲的就是人，整本书从人才的管理到人的工作环境，再到如何发现人才，最后凝聚团队，围绕人展开了一系列的讨论，突出人才是知识企业的核心。</p><p>&emsp;&emsp;整本书开篇，作者就通过“我们工作中的很多问题属于社会学范畴，而非技术范畴。”提出在软件项目管理的过程中，技术并非最大的困难，而社会学范畴的人会存在大量的问题，在现实中，很多管理者仅仅将技术问题视为主要问题而对社会问题置之不理，这将会造成极大的人力资源的浪费。对于脑力劳动着来说，轻松愉悦的工作环境可以直接影响效率，项目的进度，因此管理者不可以以生产的管理手段来管理他们，在短期时间内可能是有效的，但长时间积攒的压力与急躁会导致失去热情，甚至导致人员的流失。因此，作者以“西班牙理论”这样的反例，提醒管理者，加班与压力只能让工作更快，却不能使工作更好。作为一个合格的管理者，不应该只是分配繁重任务让员工工作，而更应该创造一种员工轻松的工作氛围，引领员工热情的开展工作。</p><p>&emsp;&emsp;工作环境是员工工作的地方，其环境的好坏直接影响到了员工工作的心情以及生产效率。文中指出，一个宽松的、安静的、注重隐私的工作环境可以帮助团队更好的完成工作。一般员工想要进入专注的工作流模式，需要十五分钟，也就是说频繁的打断会造成员工无法集中注意力，降低工作效率以及满意度。在实际工作中，噪音和电话成了打断流的罪魁祸首。噪音也许来自外部环境，也许来自内部员工之间的交流或其他因素，这时一个良好的工作环境就可以尽可能低的减少噪音的频率，大大提高工作专注度。另一个麻烦就是电话，而其解决方法就是通过邮箱来代替内部电话。当有要求时，发一份邮件，当员工专注完空闲时，可以批量阅读邮件来处理，不仅解决了频繁被打扰的问题，也提高了处理问题的并行性。因此，作者强调一个良好松散的工作环境，可以使员工拥有更高的热情，同时减少了被噪声、干扰、焦急情绪所影响的可能，可以大大提高脑力工作者的工作效率。</p><p>&emsp;&emsp;接着文章讨论人的正确使用方式，人作为最重要的资源，对公司起到了至关重要的作用，因此如何聘用人才、使用人才是管理者所要面临的巨大挑战。管理者应该拥有优秀的领导力，其领导力并非指分派工作压榨劳动力，而相反应该来服务员工，为他们安排合适的工作，制定明确的工作目标，推动整个团队前进，应该起到一种催化剂的作用。同时降低人员流动也十分重要，高离职率意味着得付出高额的人员成本，想要留住人才，管理者应该提供入职培训与新晋员工的快速晋升，从长远角度来看，这可以帮助他们树立永恒之地的概念，降低离职率，提高他们的社区归属感。因此，依靠脑力劳动者的公司应该重视的在人力资源上进行投资，人对与这样的公司是至关重要的。</p><p>&emsp;&emsp;个人的能力始终是有限的，需要通过一个团队来体现价值。管理者应该要看到团队的重要性，要组织有强大凝聚力的团队来合作完成任务。一个强大的凝聚力的团队所能发挥出的作用是巨大的，员工之前可以相互激励，保持强烈的热情来攻克任务。接着书中给管理者详细的介绍了如何让一个团队凝聚起来。第一，管理者必须相信自己的团队，面对困难而不应改使用短期的防御性措施，目光要长远。第二，要明确团队的任务目标以及每一个员工的工作目标，而不是盲目的工作。第三，团队应该要属于有自己的团队工作空间，方便交流有利于形成团队文化。第四，要让团队在一段时间内专注完成一个目标，而不是同时开展多项工作。第五，不应该为了时间而牺牲产品质量，要让员工沉浸于自己的产品中，配有团队协作的成就感。第六，管理者不应该设置没有希望的截止时间来降低团队凝聚力，应该保持团队的动力与热情。最后，可以开展一些团队活动和互动来提高团队员工之前的信任。当一个强大凝聚力的团队诞生时，就会给公司创造出无限的价值。</p><p>&emsp;&emsp;最后，作者强调了企业文化以及快乐工作的重要性，管理者应该赋予员工工作的快乐，而并一味的追求利益而剥夺员工的利益。同时，管理者不应该设置条条框框来束缚员工的自由发挥。总揽整本书，全书围绕人所展开，阐述了人对于脑力劳动企业的重要性。并给予管理者对人才任用的启示，将最大的减少人员流失，才能充分发挥了人才的价值。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《人件》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Java中的类加载机制</title>
      <link href="/2019/10/19/xiang-jie-java-zhong-de-lei-jia-zai-ji-zhi/"/>
      <url>/2019/10/19/xiang-jie-java-zhong-de-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p>我们都知道Java的平台无关性是其一大特点，所谓平台无关性是指Java的源码会被编译成Class字节码文件，其字节码文件可以被不同平台上的JVM所解析然后执行，从而实现跨平台性。那么这一过程是具体是如何实现的呢？</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器（ClassLoader），顾名思义就是专门用来加载类的，其作用是负责将class文件读入内存，并为之生成对应的java.lang.Class对象。当JVM启动时，会形成有3个类加载器组成的初始类加载器层次结构：</p><ul><li>Bootstrap ClassLoader   这个加载器主要负责加载Java中核心包，例如java.lang.*</li><li>ExtClassLoader  这个加载器主要负责加载Java中的扩展包，例如javax</li><li>AppClassLoader  这个加载器主要负责加载应用程序主程序类</li></ul><p>同时，也可以自定义ClassLoader。通过类加载器，可以将我们的Class字节码文件转化为相应的二进制字节流到JVM中。那么此时就会出现一个问题，一个Class字节码文件该由哪个类加载器来执行呢？</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制就是为了解决多个加载器重复解析同一个字节码文件，当同时存在两个或多个全限定名完全一致的情况下。该如何选择加载哪个类。这就是双亲委派机制要做的工作。其机制如下图：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-lei-jia-zai-ji-zhi/1.png" alt="双亲委派机制"><br>当有一个出现Class字节码文件时，首先交由自定义加载器看是否加载，如果加载了则不继续提交给父加载器，如果不加载则提交给父加载器AppClassLoader。同样如果AppClassLoader不加载则继续提交给其父加载器ExtClassLoader，如果ExtClassLoader还是不加载则最终提交给Bootstrap ClassLoader。此过程自底向上。<br>然后Bootstrap ClassLoader开始从尝试加载此字节码文件，如果它表示无法加载，则向下转交给子加载器。以此类推，如果最终自定义类加载器也无法加载此字节码文件则抛出异常。此过程自顶向下。</p><p>此流程即为双亲委派机制，通过这个机制可以有效的避免对字节码文件的重复加载。</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类的加载机制其实就是将字节码文件加载的jvm的内存之中。在JVM中并不是一次性把所有的文件都加载到，而是一步一步按照步骤来加载。JVM启动时会通过不同的类加载器加载不同的类，而且同一个类也不可能由多个加载器来进行加载。<br><img src="/2019/10/19/xiang-jie-java-zhong-de-lei-jia-zai-ji-zhi/2.png" alt="类加载过程"><br>之前，通过类加载器实现了第一步，加载过程。<br>接着，用户想要拿到JVM中的Class对象，有两种实现的方法，一种为forName()方法，一种为loadClass()方法，其过程完全不同。</p><ul><li>forName()实现<pre class=" language-java"><code class="language-java">Class <span class="token class-name">test</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>直接通过Class的静态方法可以获取想要的对象，此过程会自动实现图中的链接和初始化阶段。</li></ul><ul><li>loadClass()实现<pre class=" language-java"><code class="language-java">ClassLoader cl <span class="token operator">=</span> Test<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Class <span class="token class-name">test</span> <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>首先获取处理该字节码的类加载器，然后通过类加载器生成用户想要的对象，和forName()方法不同的是此方法只完成了加载阶段，并没有实现链接和初始化阶段。那么这种方法有什么应用场景呢？在Spring框架中，可以通过loadClass()方法实现一种加载方式–懒加载模式。只将类加载到JVM中，只有当该类真正用到的时候才会被检查和初始化，这样可以大大的提高运行的效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Java中的GC机制</title>
      <link href="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/"/>
      <url>/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="GC概述"><a href="#GC概述" class="headerlink" title="GC概述"></a>GC概述</h2><p>GC（Garbage Collections），就是垃圾回收机制。在C或C++中，开发人员需要手动的对内存进行分配和回收，需要时刻关注以防止出现内存泄漏。但在Java中，Java程序不用像C++程序在程序中自行处理内存的回收释放。这是因为Java在JVM虚拟机上增加了垃圾回收(GC)机制，用以在合适的时间触发垃圾回收，将不需要的内存空间回收释放，避免无限制的内存增长导致的OOM。<br>那么我们来研究下JVM中是如何实现GC机制的。本篇文章将从以下几点展开：</p><ul><li>如何判断垃圾</li><li>常见垃圾回收算法</li><li>详解分代收集算法</li><li>垃圾收集器</li></ul><h3 id="什么样的对象可以被认为是垃圾？"><a href="#什么样的对象可以被认为是垃圾？" class="headerlink" title="什么样的对象可以被认为是垃圾？"></a>什么样的对象可以被认为是垃圾？</h3><p>什么样的对象可以被认为是垃圾，这是一个十分关键的问题，需要准确的找出哪些对象正在使用，哪些对象不会使用，也是JVM实现GC的第一步。JVM提供了两种算法来实现垃圾的判断：</p><p>1、引用计数器<br>当对象被生成时，同时伴随有一个计数器。当这个对象被引用是，计数器就+1。当引用失效时，计数器则-1。当计数器等于0时，则认为该对象已经“死亡”。但这种算法存在一个致命的问题，就是无法解决“循环引用”的现象，即对象之间相互引用。所以这种算法没有很少被使用。</p><p>2、可达性分析算法<br>JVM会将所有的引用关系转化为图结构，以GC Roots对象为起始点，并向下搜索标记，标记到的即为存活，没标记到的即为死亡。这也是目前主流的垃圾判断算法。其过程如下图所示：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/1.png" alt="可达性分析算法"><br>那么如何选定GC Roots对象，一般JVM会在以下几种对象中选取：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）的引用的对象</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>当可以判断出了内存中的垃圾时，JVM可以通过算法来回收垃圾了，JVM中一般有以下几种回收算法：</p><p>1、标记—清除算法<br>通过遍历内存，标记出所有需要清理的垃圾，然后等标记完成后统一回收。标记清除算法存在的问题是，当回收垃圾后，内存会出现大量不连续的内存段，如果此时要存储占有较大内存的对象，则无法满足，此时JVM会再次触发垃圾回收机制。其流程如下：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/2.png" alt="标记-清除算法"></p><p>2、复制算法<br>首先将内存平分为AB两部分，每次只是用其中一部分，当A部分内存存满后，将A内存中所有存活的对象移到B内存中（有序），然后清空A全部内存。复制算法虽然解决了内存的不连续性，但却需要牺牲一半的内存容量，代价较高。其流程如下：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/3.png" alt="复制算法"></p><p>3、标记—整理算法<br>标记—整理算法是标记-清除算法的改进，在标记过后，将存活内存移到一端按序存放，然后清除最后存活内存以后的所有内存。其流程如下：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/4.png" alt="标记-整理算法"></p><p>4、分代收集算法<br>分代收集算法是目前大部分JVM所采用的算法，它将内存按生命周期分为不同的区域，然后对不同区域对使用不同的收集算法。接下来将详细描述分代收集算法中区域的划分以及不同区域具体的回收机制。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>在分代收集算法中，JVM会将内存按对象生命周期划分为不同的区域。在JDK1.8以前，内存堆分为新生代、老年代和永久代。在JDK1.8及以后，内存堆只被划分为了新生代和老年代（划分比例1:2）。</p><p><strong>新生代</strong>：大部分新创建的对象都会存放在新生代中，新生代是以生命周期较短划分出来的，所以里面的大多数对象都是朝夕生死的，只有少部分生命周期较长的会被转移到老年代中。新生代中分为三个部分，一个eden区和两个survive区（form和to），其分配比例为8:1:1，其大致结构如下：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/5.png" alt="新生代结构"><br>那么对象是如何存储的呢，首先每一个新对象会被存放在eden区，由于新生代生命周期较短，所以80%的对象已经死亡。此时JVM将还存活的对象记录年龄为0（出生了）。经过一段时间，当eden区被填满时，会触发Minor GC机制处理垃圾。通过上面讲到的复制算法将eden区存活的对象存放到from区，并将年龄增加一岁（活过了一次Minor GC）。其流程如下图：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/6.png" alt="经过一次GC后"><br>当eden区又被填满时，会再次触发Minor GC机制。此时eden和from区都会有大量的对象死亡，同样利用复制算法，将eden和from中存活的对象复制到to区，并将其年龄+1。此时to区变为from区，from区变为to区。其流程如下：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/7.png" alt="又经过一次GC后"><br>如此反复循环，其关键是永远保持to区为空，用于存放 Minor GC后存活下来的对象。经过不断的Minor GC后，存活下来的对象年龄不断增长，直到年龄到达15岁（JVM默认）。JVM就会认为你这个对象生命周期过长，不适合在生命周期较短的新生代中生活。所以将这些对象转移到 了老年代。</p><p><strong>老年代</strong>：和新生代相反，这里存放着生命周期较长的对象。但老年代中也同样会出现死亡的现象，只是没有新生代这么频繁。当老年代中被填满时，就会触发Full GC来回收整的堆内存上的垃圾（新生代+老年代）。此时，老年代中不像新生代中使用复制算法（因为老年代存活率高，复制算法效率低），而是使用标记清除或标记整理算法来实现垃圾的回收。</p><p>但在实际情况中也会出现一些特殊情况：<br>1、当新建的对象太大超过JVM默认的一个值时，会讲这个对象直接存放在老年代中。</p><p>2、当eden中存活下来的对象，想要放到survive区却没有足够的空间时，则会直接存放到老年代中。</p><p>3、如果survive中存活对象进入老年代，但老年代没有足够的内存空间时，就会触发一次Full GC。</p><p>以上就是GC机制中的基本理论原理，在实际中JVM会通过垃圾收集器来完成垃圾收集的工作，接下来接收下垃圾收集器：</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器分为新生代的垃圾收集器和老年代的垃圾收集器，种类繁多，不同的JVM中选择不同的收集器来实现GC操作，其中主流垃圾收集器如下图所示：<br><img src="/2019/10/19/xiang-jie-java-zhong-de-gc-ji-zhi/8.png" alt="主流垃圾收集器"><br>其中新生代中主流的垃圾收集器有Serial、ParNew和Parallel Scavenge收集器。老年代中主流的收集器有CMS、Serial Old和Parallel Old。G1收集器可以同时使用在老年代和新生代。图中的连线表示收集器之间可以组合配合使用。这些收集器有各自的优缺点，在不同JVM中会使用不同的组合来完成GC。</p><p>JVM中的GC机制的大致流程就是这样，掌握GC知识一方面可以帮助我们快速排查因JVM导致的线上问题，另一方面也可以帮助我们在Java应用发布之前合理地对JVM进行调优，提高应用的执行效率、可靠性和健壮性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人月平衡的奥秘</title>
      <link href="/2019/10/18/ren-yue-ping-heng-de-ao-mi/"/>
      <url>/2019/10/18/ren-yue-ping-heng-de-ao-mi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。”   —《人月神话》</p></blockquote><p>&emsp;&emsp;花了大约一周的时间读完了软件工程管理领域的经典著作《人月神话》，初读题目便引发了我的思考，何为“人月”，又为何“神话”。在带着这两个问题阅读后，我有了这样的理解，“人月”分为人和月，在软件开发的过程中，人代表着团队开发的人数，月代表着软件开发的时间。“人月“代表着一个工程的工作量，一个五人的团队耗时两个月完成，意味着此工程花费了十个人月。那么是否可以通过增加开发人数，降低开发时间达到相同的人月数而完成工程呢？这往往是达不到的，也就是说十个人的团队耗时一个月并不能完成同样的工程，因此称为“神话”。</p><p>&emsp;&emsp;书中提到“人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。”也就是说人与月并不能完成相互的转换，造成这样的原因有这么两点，一是如果项目的任务是有序的，那么添加新的人手并没有太大意义，还是需要等待前提任务的完成。二是如果任务是无序的、可分解的，那么不同任务之间的人员交流与沟通会因为人数的变多而变得困难。因此精简的小团队更适合小型项目的开发，而如何进行大型项目的开发这是这本书着重想要阐述的。</p><p>&emsp;&emsp;对于大型大项目的开发，作者提出了“外科手术”团体，团队中需要分配1/10的专业的开发人员来保证概念的完整性，并协调工作降低沟通的工作量。概念完整性是作者提出的核心观点，一个产品必须向每一个用户提供场景应用，功能体验和清晰的使用操作，概念的完整性决定了产品的易用性。所以这1/10的人承担着一个项目的重要职责。然后项目经理必须要制定正式的项目文档，通过项目文档可以记录清晰的策略，并减少交流产生的矛盾，同时可以使项目经理清楚的知道项目所处在的状态，一旦发现项目有所偏离，及时的可以对项目进行调整。所以项目文档是十分有必要的。接着项目最重要的环节在于交流与沟通，作者通过分析“巴比伦塔”的失败，表明团队应该尽可能多的进行交流与沟通，主要通过会议以及工作手册来实现。工作手册需要提前详细的制定，并且保证每一个团队成员都有一份，成员应该详尽的知道手册的工作内容，可以达到交流的效果，同时工作手册应该要及时的更新，以避免出现不必要的错误。沟通与交流是保证项目进度的关键一环。在一个完整的项目中，计划占1/3，编码占1/6，测试占1/2。在此之前所有的工作属于1/3计划部分，但却是十分重要的，直接影响后面所有的进度。接着是其中1/6编码部分，一个产品的困难在于规格说明、概念和测试，而并非技术方面，所以编码在其中的占比是最小的，项目经理制定策略来规定通用的开发工具（操作系统、语言等），系统结构师用来保证系统的完整性，加强不同团队成员的导向与交流，而开发人员只需编码来实现自己团队的模块的完整性，保证团队内的沟通。最后的测试部分工程量是最大的，十分耗时耗力的，占了整个项目一半的时间，其中又分为1/4的软件测试与1/4的系统测试。其中最困难的就是系统测试，我们需要通过系统的、可计划的方法，开发大量复杂的辅助测试平台来实现系统测试，同时需要有人负责构件的变更和版本控制。测试的重要作用在于通过不断测试优化消除bug，可以更好的保证系统的完整性，提供更好的用户体验，所以从用户的角度出发应该在测试上投入最多的时间。以上就是在大型项目的开发过程中，应该如何对其进行有效的管理。</p><p>&emsp;&emsp;在书的后半部分，作者以“没有银弹”为主题展开讨论，那么何为“没有银弹”呢？“没有银弹”指的是在十年内，没有任何一种技术或管理方法可以使软件的生产率、可靠性和整洁性获得数量级上的提升。我们知道，在开发任何软件系统时都有无法规避的四大特性：复杂性、可变性、一致性和不可变性。其中复杂性是造成“没有银弹”理论成立的重要因素之一，软件的复杂导致了团队沟通困难，产品的易用性可靠性下降，进度延时等一系列复杂的问题，是造成软件开发困难的内在根本原因。要想实现一个完美的产品，必定要制定精细的项目计划，长时间的开发交流与研究，不断反复的测试调试，在这些环节中并没有一种技术或方法可以一劳永逸的降低项目开发的复杂度，即使一些前沿技术可以提高效率但也并没有达到数量级上的提升。因此，“没有银弹”的理论以目前的技术来看是有所道理的。但未来是否有可能打破“没有银弹”的理论呢？随着技术的提升，人工智能等领域的不断成熟，或是面向对象编程的新语言的出现，或是未来某种技术、管理方法被挖掘，都会有打破“没有银弹”理论的无尽的可能。到那时，软件开发将进入一个全新的时代，更低的成本，更简单易用的技术，更方便统一的管理方法，得到的却是更高的生产率。因此，未来的这些种种都有可能会让软件开发在生产率、可靠性和整洁性上达到一个数量级上的提升。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《人月神话》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring之DI</title>
      <link href="/2019/10/18/spring-zhi-di/"/>
      <url>/2019/10/18/spring-zhi-di/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring中的DI"><a href="#Spring中的DI" class="headerlink" title="Spring中的DI"></a>Spring中的DI</h2><p>在<a href="https://zmhuihuihui.github.io/2019/10/18/spring-zhi-ioc/" target="_blank" rel="noopener">上一小节</a>中，我们阐述了Spring中的核心思想IOC，那么在Spring中是如何实现IOC思想的呢？<br>在Spring中通过DI（依赖注入）的方式来实现IOC思想的。那何为依赖注入呢？即指Spring容器通过Spring Bean对象来创建和维护对象之间的依赖关系，通过DI将对象的依赖关系动态的注入到对象中去，粗略的讲Spring Bean负责创建管理对象，DI负责对象的初始化。</p><h3 id="Soring-Bean对象"><a href="#Soring-Bean对象" class="headerlink" title="Soring Bean对象"></a>Soring Bean对象</h3><p>Spring Bean是在Spring框架运行时所管理的对象，是Spring应用程序的基本构件块。Spring框架中BeanFactory负责创建并维护Bean实例，将系统配置和依赖关系从代码中独立了出来。在实际操作我们应该指定将哪些类用作Bean交由Spring管理，并不是所有类都要交由Spring管理。其对类的具体管理包括：</p><ul><li>创建一个对象</li><li>通过依赖注入提供依赖项</li><li>拦截方法调用以提供额外的框架功能</li><li>销毁一个对象</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>那么接下来就来看看Spring是如何实现IOC和DI的。首先，看一下整个项目的整体框架。<br><img src="/2019/10/18/spring-zhi-di/1.png" alt="项目框架"></p><ul><li>entity目录，存放实体类，分别有Car抽象类和Person抽象类。</li><li>CarImpl目录和PersonImpl目录，分别存放Car的实现类和Person的实现类。</li><li>main目录，存放主函数。</li><li>resoucrces目录，存放资源配置，目前只存放spring的配置文件。</li><li>pom.xml，maven的配置文件。</li></ul><p>然后，我们需要导入Spring框架所需要的包，一共有以下几种。<br><img src="/2019/10/18/spring-zhi-di/2.png" alt="依赖包结构"><br>其中spring-context包需要依赖右边四个包，所以我们只需要在maven中添加spring-context依赖就会自动导入Spring所有包。其pom.xml配置如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h3 id="xml注入"><a href="#xml注入" class="headerlink" title="xml注入"></a>xml注入</h3><p>配置完Spring框架后，就要实现注入。首先先实现第一种注入方式xml注入。之前我们说过，要将对象的控制权交由Spring容器处理，如果使用xml实现，首先得创建一个spring xml的配置文件，其结构如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><p>这是系统自动写好的开头，我们需要在beans标签中添加我们的对象。回到上一小节的例子，张三想要开车回家，那么我们首先要先获取车这个对象，那么我们先把所有车交由Spring管理。这里用到bean标签：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>carA<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity.CarImpl.CarA<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>carB<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity.CarImpl.CarB<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p><bean>标签这里用到两个属性，第一个id即为实例的名字，第二个class即为你要交由Spring管理的类。这样我们就将A车和B车对象都交由Spring容器管理。接着我们需要一个ZhangSan对象，使用相同bean标签:</bean></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ZhangSan<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity.PersonImpl.ZhangSan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>carA<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>这里有所不同，id和class和上述一样，但在bean标签中还有constructor-arg子标签。我们想象一下，如果我们亲手new一个对象，就会使用到构造器，那么这里也同样的道理，在将对象创建时，有时可能会使用有参数的构造器，那么就会用到constructor-arg标签实现构造器注入，这个标签必须与类中构造器相匹配，即相当是调用这个构造器：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZhangSan</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    ……    <span class="token function">ZhangSan</span><span class="token punctuation">(</span>Car car<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>car <span class="token operator">=</span> car<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ……<span class="token punctuation">}</span></code></pre><p>因为这里的car为引用类型，所以使用ref属性，其值carA指的是上面id=carA的对象。如果想要初始化的值为int等普通类型，则使用属性value，直接赋值。有时后可能没有在构造器中实现注入，还可以使用set方法注入：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ZhangSan<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity.PersonImpl.ZhangSan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>carA<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>这里使用了property标签，必须要求类中有对应的set方法，效果和构造器注入相同，即相当于使用了这个方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZhangSan</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    ……    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCar</span><span class="token punctuation">(</span>Car car<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>car <span class="token operator">=</span> car<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ……<span class="token punctuation">}</span></code></pre><p>此时我们将carA、carB、ZhangSan都交由Spring管理，不用我们手动创建对象了，那么我们该如何拿到这些对象呢？在主函数中，分为两步：</p><ul><li>获取到Spring上下文</li><li>从Spring上下文的容器中获取对象。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1、获取spring上下文</span>        ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2、获取ZhangSan对象</span>        Person ZhangSan <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"ZhangSan"</span><span class="token punctuation">,</span> ZhangSan<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ZhangSan<span class="token punctuation">.</span><span class="token function">goHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中 ClassPathXmlApplicationContext类从类名就可以看出，它是通过xml配置文件中加载Spring上下文的，所以只需把xml文件名传入就可以获取了上下文。得到Spring上下文，意味着得到了Spring的“心脏”，通过上下文的getBean()方法可以获取对象，其中第一个参数为之前配置的对象的id，第二个参数为实体类的class对象。接着就可以执行对应的方法得到结果：<br><img src="/2019/10/18/spring-zhi-di/3.png" alt="运行结果"><br>这就完成了xml实现注入，然而大量的配置文件总是麻烦的，在大多数情况下我们通常会使用第二种简洁的方法，用注解实现注入。</p><h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><p>使用注解注入就不用大量配置xml文件了。直接定位到想要交由Spring管理的类，以CarA为例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"carA"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CarA</span> <span class="token keyword">extends</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is starting!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is turning left!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is turning right!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is stopping!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>只需在CarA类名上面添加一个注解@Component就实现了相当于xml中的bean标签，其中的value即使实例的名字，相当于xml中的id。对比复杂的xml配置，注解的方式清晰明了。同样对于ZhangSan类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"ZhangSan"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZhangSan</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"carA"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Car car<span class="token punctuation">;</span>    <span class="token function">ZhangSan</span><span class="token punctuation">(</span>Car car<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>car <span class="token operator">=</span> car<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ……<span class="token punctuation">}</span></code></pre><p>通过@Component注解把ZhangSan类交由Spring管理，然后直接在Car的属性上添加注解实现初始化。@Autowired注解可以实现自动注入，它会从Spring容器中寻找与此类型相匹配的对象注入进去，在Spring容器中我们有CarA和CarB都可以注入，此时存在不唯一性，于是使用@Qualifier注解实现指定注入，这里我们要求张三开A车回家，就指定value = CarA进行注入。</p><p>此时把所有对象都交由Spring容器管理，最后还需修改一点点xml文件。</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation=               "http://www.springframework.org/schema/beans                http://www.springframework.org/schema/beans/spring-beans.xsd                http://www.springframework.org/schema/context                http://www.springframework.org/schema/context/spring-context.xsd">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><p>标签context:component-scan的作用是开启注解扫描，base-package为扫描范围。我们对entity包下全部扫描，就可以实现自动扫描注解然后将对象放入Spring容器中。需要注意的一点是此标签在context包中，所以beans标签中需要添加context相关的命名空间。xml配置好了后，到主函数，主函数无需任何改动直接运行，就可以得到与xml注入相同的效果。</p><p>以上就是Spring中的IOC和DI的基本使用方法。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring之IOC思想</title>
      <link href="/2019/10/18/spring-zhi-ioc/"/>
      <url>/2019/10/18/spring-zhi-ioc/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring中的IOC"><a href="#Spring中的IOC" class="headerlink" title="Spring中的IOC"></a>Spring中的IOC</h2><p>IOC（Inversion of Control），其名称是控制反转，是一种重要的设计思想,实现了程序设计的松耦合。其分为两个部分控制与反转，那么这里就会有两个重要的问题：控制什么？反转什么？</p><ul><li>控制：指控制对象的生命周期。</li><li>反转：指将对象的控制权交由Spring容器处理。</li></ul><p>现在理解起来可能十分困难，等文章最后我们再来详细聊聊控制反转。现在通过一个例子来引出IOC。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>假设现在有这么一个场景，有一个人每天下班都需要开车回家。那么怎么用编程来描述这个事件呢？首先要有定义一辆车。这辆车名叫carA，有四个方法分别为启动、左转、右转、熄火。其结构如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CarA</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//启动</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is starting!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">turnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//左转</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is turning left!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">turnRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//右转</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is turning right!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//熄火</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"carA is stopping!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后需要定义一个人。这个人叫张三，拥有一辆carA车，并且有一个回家的方法。其结构如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZhangSan</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> CarA carA<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ZhangSan</span><span class="token punctuation">(</span>CarA carA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>carA <span class="token operator">=</span> carA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">goHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        carA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        carA<span class="token punctuation">.</span><span class="token function">turnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        carA<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>张三离家很近，只需开车启动、左转、熄火就到了。那么每天张三只需要调用goHome()方法就能回到家了。直到有一天，张三凭借着自己的积蓄，买了第二辆车carB。那么同样我们需要定义这么一辆车carB，其结构和carA完全相同，并且需要把ZhangSan类中的所有和车有关的都换成carB。</p><p>这时我们就发现问题了，如果某天张三拥有十辆车了，一天一辆轮着开，那么我们每天都需要频繁的修改ZhangSan类拥有的车及goHome方法，这是十分不合理的。</p><p>这时我们需要明白，其实ZhangSan只需要回家的操作，他本身并不关注开的是什么车。换句话说，他家的保镖只需要在他公司下面停一辆车供张三下班后开回家，张三本身不关心开什么车回家。那么我们就可以进行重构，我们先抽象出这个车,其结构如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">turnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">turnRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接着，ZhangSan类只需要把车改为抽象车，这样就可以实现每天开不同的车（多态）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZhangSan</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Car car<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ZhangSan</span><span class="token punctuation">(</span>Car car<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>car <span class="token operator">=</span> car<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">goHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        car<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        car<span class="token punctuation">.</span><span class="token function">turnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        car<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此时我们可以在主函数中这样测试。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Car car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CarA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//今天开A车</span>        ZhangSan zhangSan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZhangSan</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span><span class="token punctuation">;</span>        zhangSan<span class="token punctuation">.</span><span class="token function">goHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这样就可以解决上述的问题，张三今天想开什么车，就new一个车，然后回家，省去了在ZhangSan类中进行修改。但还有问题，张三每天想开不同的车就得new不同的车，他嫌太麻烦。他想可不可以每天公司下面停着自己的所有车，下班想开哪一辆开哪一辆。<br>这时引出了本文的主题IOC。我们可以把对象事先存放在Spring容器中（先把所有车停到公司下面），然后当我们需要某个对象时直接从Spring容器中取（下班后取一辆车）。这样就不用每次频繁的修改源代码new不同的对象了。此时再回过头来谈谈什么是IOC（控制反转）。</p><h3 id="再谈IOC"><a href="#再谈IOC" class="headerlink" title="再谈IOC"></a>再谈IOC</h3><p>控制反转即将对象的控制权交由Spring容器处理。在传统的开发模式下，我们往往会自己new对象，此时对象的控制权在程序员手中，什么时候需要用直接new一个就行。而有了Spring IOC，程序员不需要自己手动new对象，Spring会把所有对象创建好放到了一个容器中，由Spring Bean进行统一管理，程序员想用直接拿就好了。<br>由此可以看出Spring的核心思想控制反转，对象的控制权由程序员转变到了Spring，程序员再也不用关心创建对象的过程，只需要关注对象的使用就行。同样再上述例子中，也可以抽象出Person类，实现不同的人开不同的车回家。</p><p>那么Spring框架是如何实现IOC思想的呢，将在<a href="https://zmhuihuihui.github.io/2019/10/18/spring-zhi-di/" target="_blank" rel="noopener">下一小节</a>详细描述。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
